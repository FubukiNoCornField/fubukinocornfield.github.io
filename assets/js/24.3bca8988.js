(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{237:function(t,e,s){"use strict";s.r(e);var a=s(0),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"开发流程规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开发流程规范"}},[t._v("#")]),t._v(" 开发流程规范")]),t._v(" "),s("h2",{attrs:{id:"提交规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#提交规范"}},[t._v("#")]),t._v(" 提交规范")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("Commit 的用法可以是多种多样的。例如，有的开发者喜欢只在功能更新和 bug 修复时 commit 一次，而有的开发者喜欢将 commit 作为“还原点”或“同步器”使用。我们并不强制要求开发者仅在功能更新时进行 commit，只是要求最后一次 commit 总结本次更改的内容并 PR（下文中会提到）。")])]),t._v(" "),s("p",[t._v("确保你的工作目录在项目目录（开发主项目）或在 Docs 目录（编写文档）。在 Terminal 中键入：")]),t._v(" "),s("div",{staticClass:"language-sh extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" run commit\n")])])]),s("p",[t._v("并回车。之后，按照交互式提示完成 commit。")]),t._v(" "),s("h2",{attrs:{id:"基于-pull-request-的开发流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于-pull-request-的开发流程"}},[t._v("#")]),t._v(" 基于 Pull Request 的开发流程")]),t._v(" "),s("p",[t._v("功能修改或 bug 修复的最后一个 commit 提交并推送完毕之后，打开 "),s("a",{attrs:{href:"https://github.com/FubukiNoCornField/CornField/compare",target:"_blank",rel:"noopener noreferrer"}},[t._v("New Pull Request"),s("OutboundLink")],1),t._v("页面。选择“master <- <nickname>”并创建新的 Pull Request。")])])}),[],!1,null,null,null);e.default=r.exports}}]);